<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
  <title>Impact Finite Element Program.</title>
  <meta xmlns="" name="DESCRIPTION" content="Impact Finite Element Program.">
  <meta xmlns="" name="KEYWORDS" content="Impact, Finite, Element, Program, Contact, Mesh, Explicit, Implicit, Static, Dynamic, Stresses, Strains, Theory, Time, Step, Stepping, Algorithm, Simulate, Loads, Load, Constraints, Constraints, Structure, Boundary, Condition, Constraint, Rigid, Body, Solid, Solids, Material, Materials, Elastic, Failure, Elastoplastic, ThermoElastoplastic, Spring, Displacement, Acceleration, Velocity,	Воздействие, Конечных, Элементов, Контакт, Сетка, Явный, Неявный, Статика, Динамика, Напряжения, Деформация, Теория, Время, Шаг, Шаговый, Алгоритм, Моделировать, Нагрузка, Нагрузки, Ограничение, Ограничения, Структура, Граничные, Условия, Ограничения, Твердый, Тело, Твердтельное, Материал, материалы, Эластичный, Отказ, Разрушение, Упругопластической, Термо-Упругопластической, Демфер, Перемещения, Ускорение, Скорость">
  
  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-6778777-9']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
  </script>
  
</head>
<body style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<center>
<h3><font sise="+2">Usage of Impact<br>
</font></h3>
</center>
<b>Impact</b> - Impact can be run in two distincly different modes.
There is a complete GUI based environment avaliable where a solution
can be run from model to analysis. It is also possible to run the
solver isolated from command line.
<ul>
  <li><a href="Uses_us.html#gui">GUI Environment</a> </li>
  <li><a href="Uses_us.html#kernel">Solver</a> </li>
</ul>
<center><img src="gui.gif"></center>
<a name="gui"></a>
<center>
<h3><font sise="+2">GUI Modules<br>
</font></h3>
</center>
The GUI is divided into separate modules which are described as follows<br>
<ul>
  <li><a href="Uses_us.html#pre">Pre Processor</a> </li>
  <li><a href="Uses_us.html#proc">Processor</a> </li>
  <li><a href="Uses_us.html#post">Post Processor</a> </li>
  <li><a href="Uses_us.html#gr">Graph</a> </li>
  <li><a href="Uses_us.html#hlp">Help</a> </li>
</ul>
<a name="pre"></a>
<center>
<h3><font sise="+2">Pre Processor</font></h3>
</center>
<b>Pre Processor</b> is the starting point for the user. It is used
for:
<ul>
  <li>Creating geometry through the use of points, curves, surfaces and
volumes<br>
  </li>
  <li>Creation of finite element models by meshing of curves, surfaces
and volumes<br>
  </li>
  <li>Setting of loads and boundary conditions</li>
  <li>Setting of solver paramerer values such as time step etc.<br>
  </li>
  <li>Exporting of .in files which is the indata file format for the
solver </li>
</ul>
<b>Pre Processor</b> operates on a full 3D view which can be zoomed and
rotated using the third mouse button either alone or in combination
with CTRL and/or SHIFT key. <br>
<br>
On the left hand side is a tree structure of the elements in the model.
Elements can be selected here or in the 3D view directly.<br>
<br>
By double clicking on a element, the properties of that element will be
displayed and can be updated in the lower left corner.<br>
<br>
There are also a range of commands:
<ul>
  <img src="Pictures/new.gif"> <b>New</b> - Starts a new model<br>
  <img src="Pictures/open.gif"> <b>Open</b> - Opens a saved model
(.impact) or imports .nas (nastran), .stl or .in files<br>
  <img src="Pictures/save.gif"> <b>Save</b> - Saves the model (.impact
for complete model or .in for solver model)<br>
  <img src="Pictures/zoomout.gif"> <b>Zoom out</b> - zooms out. This
can also be done by pressing mouse button and CTRL and move the mouse up<br>
  <img src="Pictures/zoomin.gif"> <b>Zoom in</b> - zooms in. This can
also be done by pressing moue button and CTRL and move the mouse down<br>
  <img src="Pictures/view_top.gif"> <b>Top View</b> <br>
  <img src="Pictures/view_bottom.gif"> <b>Bottom View</b> <br>
  <img src="Pictures/view_left.gif"> <b>Left View</b> <br>
  <img src="Pictures/view_right.gif"> <b>Right View</b> <br>
  <img src="Pictures/view_front.gif"> <b>Front View</b> <br>
  <img src="Pictures/view_back.gif"> <b>Back View</b> <br>
  <img src="Pictures/view_sw.gif"> <b>SW Isometric View</b> <br>
  <img src="Pictures/view_se.gif"> <b>SE Isometric View</b> <br>
  <img src="Pictures/view_ne.gif"> <b>NE Isometric View</b><br>
  <img src="Pictures/view_nw.gif"> <b>NW Isometric View</b><br>
  <img src="Pictures/config.gif"> <b>Properties</b> - This button
allows the user to select run parameters for the .in solution file as
well as what should be visible on the screen. Examples include loads,
nodes, elements etc. To speed up the screen, deselect the ones you
don't need to see.<br>
  <img src="Pictures/material.gif"> <b>Material</b> - Defines the
different material properties that are selectable<br>
  <img src="Pictures/constraints.gif"> <b>Constraints</b> - Defines
the different constraints that are selectable<br>
  <img src="Pictures/loads.gif"> <b>Loads</b> - Defines the different
loads that are selectable
</ul>
On the top left side is a selection menu of the <b>Graphics mode</b>.
Several options are available such as
<b>Surface</b> which displays a shaded model. <b>Wireframe</b> is
faster since no shading occurs.
<b>Solid</b> is used for completely shaded view.<br>
<br>
<h4>Modelling principles</h4>
The preprocessor works with two types of graphical objects: Geometry
and Mesh. The geometry is CAD geometry but with build in mesh
attributes. A curve for example can have a mesh attached to it. It can
also have a material and a thickness which is automatically transferred
to the mesh. <br>
<br>
To generate a model, the user should start with points and then create
curves based on these points. Finally, surfaces should be created based
on the curves. If a point is later moved, the curve based on this
points will change and finally the surface when the users presses the
rebuild model button.<br>
<br>
By double clicking on a geometry, the attributes of that geometry will
appear on the edit field in the lower left corner. The user can change
any attribute and press update to modify the model. The mesh of a
surface is automatically based on the mesh of the curves which created
the surface. If the mesh is modified on a curve, the mesh on the
surface is also changed.<br>
<br>
To create geometry there is a <b>Draw</b> tab available containing the
following commands:<br>
<br>
<span style="text-decoration: underline;">Curve defining commands</span><br>
<ul>
  <img alt="point" src="Pictures/node.png"
 style="width: 16px; height: 16px;"> <b>Point</b> - Creates a point at
a given location and optionally a complementing direction vector. <br>
  <img src="Pictures/nurbcurve.gif"> <b>Nurb Curve</b> - This creates
any curve from a line to a complex 3 degree curve with any number
control points.<br>
  <img src="Pictures/arc.png"> <b>Arc</b> - Creates an arc based on a
starting point, center point and a point to define the plane. Any angle
can be specificed including a negative. This makes the arc move in
opposite direction.<br>
</ul>
<br>
<span style="text-decoration: underline;">Surface defining commands</span><br>
<ul>
  <img src="Pictures/surf_dir.gif"> <b>Tabulated surface</b> - This
surface is created by dragging a profile curve along a spine curve. The
resulting surface will contain a rectangular mesh with the number of
elements per side defined through the profile and spine curve meshes.<br>
  <img src="Pictures/surf_rev.gif"> <b>Surface of revolving</b> - Any
curve can be rotated about an axis defined by two points. The angle of
the rotation is defined in degrees (0-360). The mesh of the surface
will be defined by the mesh on the rotated curve and the specified mesh
size.<br>
  <img src="Pictures/surf_rule.gif"> <b>Ruled surface between curves</b>
-
This creates a ruled surface between two edge curves of any shape. The
mesh size will set the size on the undefined edges. A switch is
available to revese the direction of curve 2 in the cases when the
surface becomes twisted.<br>
  <img src="Pictures/surf_nurb.gif"> <b>Nurb Surface</b> - Will create
a surface between four curves. The curves must be connected to form a
closed loop. One curve can have zero length in order to define a
3-sided surface.<br>
</ul>
<span style="text-decoration: underline;">Point and Curve generating
commands</span><br>
<ul>
  <img alt="border" src="Pictures/border.png"
 style="width: 16px; height: 16px;"> <b>Boundary generation</b> -
Extracts
border points of a curve or boundary curves of a surface.<br>
  <img src="Pictures/intersect.png"> <b>Intersection</b> - Creates an
object at the intersection of two objects. For example, a point is
created at the intersection of two curves or at the intersection of a
curve through a surface.&nbsp; A curve is created as an intersection of
two surfaces.<br>
  <img src="Pictures/project.png"> <b>Project</b> -
Projects an object onto another object. A point can be projected onto a
curve or a surface. A curve can be projected onto a surface. In all
cases, a vector can be used to project in a certain direction. If no
vector is available, the projection will be orthagonal to the curve or
surface.<br>
</ul>
<span style="text-decoration: underline;">Finite element direct
generating
commands</span><br>
<ul>
  <img src="Pictures/node.gif"> <b>Node</b> - Defines a node at a
given coordinate.<br>
  <img src="Pictures/beam.gif"> <b>Elements with 2 nodes</b> - Defines
a rod, spring or beam element between two nodes. <br>
  <img src="Pictures/triangle.gif"> <b>Elements with 3 nodes</b> -
Defines a Contact_Triangle or Shell_CO_3 element between three nodes.<br>
  <img src="Pictures/quad.gif"> <b>Elements with 4 nodes</b> - Defines
a quad element between four nodes<br>
  <img src="Pictures/solid_iso_6.gif"> <b>Elements with 8 nodes</b> -
Defines a solid element between eight nodes<br>
</ul>
A second tab, <b>Modify</b>, contains all the commande for modifying
one or several objects.<br>
<ul>
  <img src="Pictures/erase.gif"> <b>Erase</b> - Deletes an object. Can
also be done by pressing the delete key on the keyboard.<br>
  <img src="Pictures/move.gif"> <b>Move</b> - Will move selected
objects a given distance. If only a point is to be moved it is easier
to double click on the point instead.<br>
  <img src="Pictures/rotate.gif"> <b>Rotate</b> - Will rotate selected
objects around a point and axis.<br>
  <img src="Pictures/scale.gif"> <b>Scale</b> - Scales selected
objects from a point with a given factor.<br>
  <img src="Pictures/transform.gif"> <b>Transform 4X4</b> - Transform
geometrically with a free 4x4 matrix for rotation and translation.<br>
  <img src="Pictures/material.gif"> <b>Materil for...</b> - Will set
the material for selected objects. Can also be done by double clicking
on a surface or curve.<br>
  <img src="Pictures/constraints.gif"> <b>Constraints for...</b> -
Will set the constraints for selected nodes.<br>
  <img src="Pictures/loads.gif"> <b>Loads for...</b> - Will set the
load condition for selected nodes or elements. <br>
  <img src="Pictures/grid.gif"> <b>Grid</b> - Will redefine the
support grid position and orientation<br>
</ul>
<a name="proc"></a>
<center>
<h3><font sise="+2">Processor</font></h3>
</center>
<b>Processor</b> The processor is where the calculation is made. It
consists of a prompt window where the solver printout is shown, an
editor where the indata file can be modified and a model viewer where
the model described by the .in file can be seen and rotated.<br>
<br>
The starting point is a .in file which has been saved from the
preprocessor (or one written by hand).&nbsp; This must be loaded into
the processor by the open model button. The solution process is then
started by the start/stop button.<br>
<br>
The results will automatically be written to a .flavia.res file which
can be loaded into the postprocessor.<br>
<ul>
  <img src="Pictures/open.gif"> <b>Open model *.in</b> - Opens a .in
file into the editor and prepares for solving.<br>
  <img src="Pictures/save.gif"> <b>Save</b> - Saves the text in the
editor. <br>
  <img src="Pictures/run.gif">,<img src="Pictures/stop.gif"> <b>Start
/ Stop</b> - Starts or stops a solution. The text in the editor is
automatically saved before the solution starts!<br>
  <img src="Pictures/find.gif"> <b>Find / Replace</b> - Finds and / or
replaces the text in the editor. The user can also use CTRL+C, CTRL + X
or CTRL + V<br>
  <img src="Pictures/solid.gif"> <b>Reload view</b> - Will generate a
three dimensional view of the model<br>
  <b>Number of CPU:s</b> - Selects on how many CPU:s the solution
should be distributed. If the user has a multi core CPU, the solution
will be faster by setting this higher.<br>
</ul>
<br>
The view of the three dimensional model can be adjusted with these
commands:<br>
<ul>
  <img src="Pictures/zoomout.gif"> <b>Zoom out</b> <br>
  <img src="Pictures/zoomin.gif"> <b>Zoom in</b> <br>
  <img src="Pictures/view_top.gif"> <b>Top View</b> <br>
  <img src="Pictures/view_bottom.gif"> <b>Bottom View</b> <br>
  <img src="Pictures/view_left.gif"> <b>Left View</b> <br>
  <img src="Pictures/view_right.gif"> <b>Right View</b> <br>
  <img src="Pictures/view_front.gif"> <b>Front View</b><br>
  <img src="Pictures/view_back.gif"> <b>Back View</b><br>
  <img src="Pictures/view_sw.gif"> <b>SW Isometric View</b><br>
  <img src="Pictures/view_se.gif"> <b>SE Isometric View</b><br>
  <img src="Pictures/view_ne.gif"> <b>NE Isometric View</b><br>
  <img src="Pictures/view_nw.gif"> <b>NW Isometric View</b><br>
  <img src="Pictures/config.gif"> <b>Configure</b> - This configures
what should be shown in the viewer.<br>
</ul>
<a name="post"></a>
<center>
<h3><font sise="+2">Post Processor</font></h3>
</center>
<b>Post Processor</b> is used to view the results from the solver.
These are saved in a file ending with .flavia.res and consists of
multiple time steps which can be selected on the left hand side of the
viewer. This is also where you can decide what should be viewed.<br>
<ul>
  <img src="Pictures/open.gif"> <b>Open *.res</b> - loads the result
file into the postprocessor for viewing<br>
  <img src="Pictures/save.gif"> <b>Save image</b> - Saves a screen
dump of the current view as a .PNG file<br>
  <img src="Pictures/saveall.gif"> <b>Save images</b> - Saves all time
steps as .PNG files<br>
  <img src="Pictures/show.png"> <b>Show/Hide</b> - Select the elements
to be hidden and press this button. Pressing with no selection will
shift view to hide mode.<br>
  <img src="Pictures/zoomout.gif"> <b>Zoom out</b> <br>
  <img src="Pictures/zoomin.gif"> <b>Zoom in</b> <br>
  <img src="Pictures/view_top.gif"> <b>Top View</b> <br>
  <img src="Pictures/view_bottom.gif"> <b>Bottom View</b> <br>
  <img src="Pictures/view_left.gif"> <b>Left View</b> <br>
  <img src="Pictures/view_right.gif"> <b>Right View</b> <br>
  <img src="Pictures/view_front.gif"> <b>Front View</b> <br>
  <img src="Pictures/view_back.gif"> <b>Back View</b> <br>
  <img src="Pictures/view_sw.gif"> <b>SW Isometric View</b> <br>
  <img src="Pictures/view_se.gif"> <b>SE Isometric View</b> <br>
  <img src="Pictures/view_ne.gif"> <b>NE Isometric View</b> <br>
  <img src="Pictures/view_nw.gif"> <b>NW Isometric View</b> <br>
</ul>
To the left of the view, there is a menu to control what is to be shown<br>
<br>
<b>Show</b> - This menu contains the following commands:<br>
<ul>
  <b>Mesh</b> - Selects if the mesh is to be shown. <br>
  <b>Deformed</b> -&nbsp; Shows the elements in the deformed state<br>
  <b>Contur fill </b> – Will show the element results as colour fields
on the mesh<br>
  <b>Gradient</b> - Another way to show element results<br>
  <b>Nodes label</b> - Will show all node numbers<br>
  <b>Elements label</b> - Will show all element numbers<br>
  <b>Gradient Result</b> - Will smooth the element results across
element boundaries<b></b><br>
</ul>
<b>Result</b> - This is where the type of element results are selected.
The user can select element stresses or strains of various types.<br>
<b>Time step</b> - Just on click on the time step to be shown. Try
holding down the mouse button and move up/down for animation.<br>
<a name="gr"></a>
<center>
<h3><font sise="+2">Graph</font></h3>
</center>
<b>Graph</b> The grapher is used to view the results from trackers or
directly from elements as curves.<br>
<ul>
  <b>Кнопочное меню.</b> <br>
  <img src="Pictures/new.gif"> <b>New</b> - Will create a new curve by
extracting results directly from the solution. By selecting
displacements, the node displacements as a function of time is plotted.
Strains and stresses are extracted from element as a function of time.
Note that the results must have been loaded into the postprocessor
module first for this command to work.<br>
  <img src="Pictures/add.gif"> <b>Open</b> - Will create a curve based
on results written in a tracker file (.trk). For how to create tracker
files, read the solver command reference.<br>
  <img src="Pictures/del.gif"> <b>Remove</b> - deletes a curve. Select
the curve in the top left table before pressing this button.<br>
  <img src="Pictures/union.gif"> <b>Union</b> - объединяет выбранные
графыки. <br>
  <img src="Pictures/save.gif"> <b>Save image</b> - Saves a screen
dump of the current view.<br>
  <img src="Pictures/saveall.gif"> <b>Save All</b> - Will save
pictures of all curves including data values and construct a .html page
for explanation.<br>
&nbsp; <br>
</ul>
<a name="hlp"></a>
<center>
<h3><font sise="+2">Help</font></h3>
</center>
This is the tab to use for documentation.
<a name="kernel"></a><br>
<br>
&nbsp;
<center>
<h3><font sise="+2">Solving problems with impact:</font></h3>
</center>
<p>The solution process is made in three stages: </p>
<ol>
  <li>Creation of a model using a <b>Pre Processor</b> or direct
writing of the Fembic indata file</li>
  <li>Solution using the Impact program</li>
  <li>Presentation of the results using a <b>Post Processor</b> and
the result files from the solution</li>
</ol>
<p>It is simplest to run Impact and the built in <b>Pre/Post Processors</b>
from the GUI. To do that, just run the ImpactGUI.bat file in this
directory if you are a Windows user
or make the ImpactGUI.sh runnable (chmod 777 ImpactGUI.sh) and run that
with ./ImpactGUI if you are a Linux/Unix/Mac user.
Alternatively, just write bash ImpactGUI.sh to start.
</p>
<a name="prepare"></a><font sise="+1"><b>Preparation of model</b></font>
<p> Impact supports a range of Pre/Post Processors. The GUI actually
contains a fully
functional <b>Post Processors</b> with a <b>Pre Processor</b> under
construction. To design models, you have
two additional choises. <b>Gmsh</b>, which is completely free and
unlimited; <b>GID</b> which is commersial
but can be run for free under a limited academic license.</p>
<p>Should you want to try <b>GID</b>, you will need to download a
version later than
6.2 since Impact uses features that are currently being implemented.
You can download <b>GID</b> from <a href="http://gid.cimne.upc.es"  target="_BLANK">
http://gid.cimne.upc.es</a></p>
<p>This is how you should set up and use GID for Pre Processing:</p>
<ol>
  <li>Run the installation file for GID and install the program.</li>
  <li>If you haven't installed Impact, proceed to do this.</li>
  <li>Look in the GID directory for a subdirectory called problemtypes
and go there</li>
  <li>Make a new subdirectory called Impact</li>
  <li>Now copy the directory Impact.gid from where you installed
Impact, making sure all files come with it (you will find this
directory under the Interfaces directory)</li>
  <li>The directory structure should now be
GiD/problemtypes/Impact/Impact.gid/some files</li>
  <li>If you now start GiD, you should find Impact as an option under
the DATA menu.</li>
  <li>Start by selecting Impact as your solver by
Data-&gt;Problemtype-&gt;Impact-&gt;Impact</li>
  <li>Fill in the problem datas under Data-&gt;Problem Data-&gt;...</li>
  <li>Create a model and mesh it (read the GiD manual for how to do
this)</li>
  <li>Set materials on all elements using Data-&gt;Materials</li>
  <li>Set boundary conditions on the nodes using Data-&gt;Conditions</li>
  <li>GiD can now export indata files to Impact via the
File-&gt;Export-&gt;CalculationFile menu</li>
</ol>
<p>This is how you should set up and use Gmsh for Preprocessing:</p>
<ol>
  <li>Download Gmsh from <a href="http://www.geuz.org/gmsh"  target="_BLANK">
http://www.geuz.org/gmsh</a> and install.</li>
  <li>If you haven't installed Impact, proceed to do this.</li>
  <li>Create models in Gmsh and save them in format 1.0 of gmsh mesh
format</li>
  <li>Import the .msh file into the Impact processor editor. It will
then be translated.</li>
</ol>
<br>
<a name="solve"></a><font sise="+1"><b>Solving of model</b></font>
<p>The solution of the problem is initiated from the GUI by loading the
file into the editor and pressing the play button. You can
also write <b>java -Xmx500m run.Impact <i>file</i></b> at the command
prompt, where <b><i>file</i></b> is the name of the indata file and
500m represents
allocation of 500 Megabytes of memory. If you have less you can reduce
this
amount with the risk of getting out of memory errors for large models.
In the case of loading a Fembic file, make sure it ends
with .in because otherwise Impact will not recognise the format. It is
also important that you are placed in the impact directory at the time
of execution.</p>
<p>If you are running some of the example problems supplied, you need
to add the path to the examples directory. The syntax then becomes: <b>java
run.Impact -Xmx500m<i> examples/file</i></b> where file applies as above.</p>
<p>If all goes well, you should now see the indata file being parsed by
impact and the solution process initiated. Each time results are
written,
a notice will be written to the screen and you will see that execution
is
in progress. A solution can take considerable time, so be patient.</p>
<br>
<a name="visual"></a><font sise="+1"><b>Visualization of results of
calculation</b></font>
<p>The results are printed to the flavia.res and flavia.msh files. They
will end up in the same directory as your sourcefile. These are tailor
made for the internal <b>Post Processor</b>, but are also readable
from the GID Post Processor</p>
<p>If you want to view the results with the internal <b>Post Processor</b>,
just swith
to the <b>Post Processor</b> tab and load the .flavia.res file. The
model should now
show up on the screen. Rotation, moving and zooming is done by holding
down any of the mouse buttons while moving the mouse.</p>
<p>If you want to use GiD as a viewer, start by firing up GID and
switch to Post Processing mode. Next read in the result file
flavia.res. The mesh (flavia.msh) file will be read automatically. You
should now see the model on the screen. </p>
<p>Press ctrl-d to set the timestep for deformation. Go from the top of
the menu, starting by selecting deformation and then time analysis.
Select
timestep 0, magnification factor 1.0 and then press apply.</p>
<p>Next press ctrl-v and select the results , time analysis and contour
fill. Finally, select gausspointstress and apply.</p>
<p>Finally, press ctrl-m. You should now see the results as an
animation. There are plenty of ways to view your results, but I refer
to the GID users manual for that.</p>
<a name="Fembic"></a>
<p><u>Summary of how you should use GiD for Post Processing (looking at
the results)</u></p>
<ol>
  <li>Fire up GID and switch to Post Processing mode.</li>
  <li>Open the xxxxx.in.flavia.res
file. If all goes well, you should be able to see your model.</li>
  <li>Press ctrl-d to set the timestep for deformation.</li>
  <li>Go from the top of the menu, starting by selecting deformation
and then
time analysis.</li>
  <li>Select timestep 0,
magnification factor 1.0 and then press apply.</li>
  <li>Next press ctrl-v and select the results , time analysis and
contour fill.</li>
  <li>Finally, select gausspointstress and apply.</li>
  <li>Next press ctrl-m to get a nice animation!</li>
</ol>
<br>
<a name="cluster"></a>
<center>
<h3><font sise="+2">Impact Cluster Implementation</font></h3>
</center>
<p>As of version 0.5.3, Impact supports calculations performed across a
networked set of clients often referred to as a cluster. This allows
Impact to split up a model into smaller parts and distribute them over
the network, letting a client calculate only a unique section of the
model and thereby speeding up the calculation. There is no need to have
a special type of network although a capacity of 100Mbit or greater is
preferrable. This is standard today on most PC:s.</p>
<p>The network communication and synchronisation is a complex topic.
Therefore, Impact uses a special software to handle all this, called
JavaParty. Developed by the University of Karlsruhe this software is
100%PC% java in itself which means no further dependencies.
Furthermore, JavaParty assumes there is a way to connect from one
client to another without a password. Default setup uses ssh (secure
shell) login and how to set this up correctly is explained at the
JavaParty webpage. A link to JavaParty as well as downloads is
avalilable on the Impact webpage </p>
<p>Impact assumes that your directory is shared across the clients in
the network. This is the most common setup on a LAN and is accomplished
by NFS or similar. If this is not the case, you have to arrange this
with the system administrator. Reason for this assumption is that the
printout of the results become significantly simpler to implement since
all the clients can access the same file.</p>
<p>For more details on the cluster implementation, see the programmers
manual</p>
<br>
<a name="contact"></a>
<center>
<h3><font sise="+2">Contact handling in Impact</font></h3>
</center>
Contacts in impact are handled by two element types:
<ul>
  <li> Contact_Triangle (CT) </li>
  <li> Contact_Line (CL) </li>
</ul>
<p> The CT is used to sense contact between nodes and surfaces and the
CL senses contact against other CL elements. Together, these two
elements can be used to enable contact detection for most cases and
models. Both of them are classified as elements which means that they
can directly be part of a model mesh as all elements. The user can for
example model a wall or a complex rigid contact surface with them.</p>
<p> Since they only have the sole purpose of sensing contact, the have
no stiffness at all. This means that if they are used on their own in
the model, the nodes connecting them should be fixed by constraints to
prevent them from drifting when in contact. It also means that the user
can use them in combination with ordinary elements to provide contact
sensing where this is not default. </p>
<p> One example where this is useful is when a body has been meshed
using solid elements, for example an engine block in a car. This body
can then be "dressed" on the outside with a second mesh of contact
elements to provide the contact sensitivity against other elements in
the car. Any contact sensing inside the engine block is not needed and
valuable calculation time can then be saved with this approach.</p>
<p> Some elements have contact sensing as default. Examples of these
are: </p>
<ul>
  <li> Shell_C0_3 </li>
  <li> Shell_BT_4 </li>
  <li> Rod_2 </li>
  <li> Beam_2 </li>
</ul>
<p> When any of these elements is created, one or several contact
elements are created by default. These are embedded inside the element
and share the element nodes. The rod and beam elements use the
Contact_Line element to sense contact. The Shell elements use the
Contact_Triangle element to sense contact against the surface and
optionally Contact_Line elements at the edges to sense contact against
other edges. </p>
<p> The contact elements drain quite a bit of computing resources and
as the number of elements increase, so does the amount of computing
power since the increase is more than linear. Therefore, some of the
elements have options to reduce the contact resolution. This means that
the contact sensing will be less accurate during large deformation of
the elements, but the solution will run faster. For this reason,
contact sensing has also not been implemented in the solid elements
since the user can best minimise the amount of calculations needed, by
distributing the contact element where they are needed. </p>
<p> The details of how contact sensing is implemented is explained in
the programming manual. </p>
</body>
</html>
